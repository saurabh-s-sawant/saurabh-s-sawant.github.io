<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Exploring Type Erasure as a Design Pattern: A Generic Materials Solver | Saurabh S. Sawant </title> <meta name="author" content="Saurabh S. Sawant"> <meta name="description" content="Exploring possibility of using type erasure as a design pattern through an example of a generic materials solver."> <meta name="keywords" content="saurabh-s-sawant, saurabh-sawant, portfolio, website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://saurabh-s-sawant.github.io/blog/2024/typeErasure/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Saurabh </span> S.  Sawant </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Research </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Exploring Type Erasure as a Design Pattern: A Generic Materials Solver</h1> <p class="post-meta"> March 16, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/design-patterns"> <i class="fa-solid fa-hashtag fa-sm"></i> design_patterns</a>     ·   <a href="/blog/category/code"> <i class="fa-solid fa-tag fa-sm"></i> code</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p><span style="font-size: larger;"><b><strong>Problem Statement / Motivation</strong></b></span><br> Consider this problem: we want to design a materials solver that computes the transport of electrons through different materials. Let’s say we opt for a super accurate numerical method, like quantum transport based on Schrodinger’s equation.</p> <p>This method involves many steps and details, and we want our code to handle various materials. Implementing the method for each material could vary depending on the material’s data structure and physics. So, how should we design this code?</p> <p>My initial thought is to use inheritance — have a base class defining an interface for the algorithm, with some default implementations that derived material classes can override. The base class can be a template class where the template parameter defines the relevant data structure, and the materials are specializations of this class template. We can store instantiated materials as pointers to the base class and use dynamic polymorphism to perform the algorithm. Although there are more nuances to this setup, let’s keep it simple. This design allows for extending to different materials as well as modeling multiple copies of a given material together.</p> <p>However, what if there are multiple possible implementations for one of the steps of the algorithm? Creating another derived class for each material isn’t viable, as it leads to an intractably deep inheritance hierarchy, too many derived classes, and duplication.</p> <p>The typical, well-tested solution to this problem is the Strategy Design Pattern, as explained in the Gang of Four book, or described beautifully on <a href="https://refactoring.guru/design-patterns/catalog" rel="external nofollow noopener" target="_blank">refactoring.guru</a>.</p> <p>The Strategy design pattern abstracts implementation details into a strategy for executing a particular operation, such as step 1 of the algorithm. This operation can have multiple implementations without modifying the base class. This allows us to interchange the object for implementing the operation at runtime. This design results in three architectural levels: high-level, composed of the base class defining the algorithm’s interface; intermediate level, where we define different materials and corresponding strategies for their operations; and the low level, which contains all implementation details such as concrete strategies.</p> <p>However, what if someone else on our team wants to develop a different, perhaps lower-fidelity numerical method (e.g., a Boltzmann transport method) for material transport, also capable of handling different materials within the same general framework for material transport?</p> <p>Clearly, we don’t want material classes to depend on a particular method defined previously as the base class. If we do that, we’ll end up duplicating a good chunk of the code that defines material characteristics.</p> <p>So, what is the best design to handle this?</p> <p>Thankfully, a few months ago, I discovered Klaus Iglberger on the internet through his engaging lectures at CppCon. In his lecture, “<a href="https://www.youtube.com/watch?v=4eeESJQk-mw&amp;t=2889s" rel="external nofollow noopener" target="_blank">Breaking Dependencies: Type Erasure - A Design Analysis</a>,” he described the use of type erasure as a design pattern. He used an example of shapes to illustrate this pattern, which combines three design patterns: external polymorphism, bridge, and prototype, to achieve something remarkable.</p> <p>His example of shapes resonated a lot with the materials problem I described above, and more importantly, the problem we all encounter a lot in scientific code development: dealing with dependencies. Code components become too coupled to each other for any meaningful extension to happen without breaking the Open/Closed principle.</p> <p>Following his video, here is the dummy code I wrote. If I had come across this two years ago, I would have made different decisions in my own development. But hey, there will be many opportunities to code. So, I consider myself fortunate to have come across this. I hope you do too.</p> <p>(On a side note) Althogh the Devin AI is learning to code, I highly doubt it would discover such design strategies on its own. So, the idea of AI replacing developers remains more of a wishlist for now.</p> <p><span style="font-size: larger;"><b><strong>Type Erasure in Action</strong></b></span><br> I would jump straight to main() and demonstrate what we can do with type erasures. I can define a vector of materials that follow the steps of my particular algorithm, execute these steps polymorphically (that’s what external polymorphism let’s you do), completely decouple material details from the operations that may be performed on the material, and have flexibility for multiple implementations of those operations.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"materials/materials.H"</span><span class="cp">
#include</span> <span class="cpf">"algorithm_impl/algorithm.H"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="cm">/* Materials that we would Algorithm to be executed */</span>
    <span class="k">using</span> <span class="n">Materials</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">Materials</span> <span class="n">materials</span><span class="p">;</span>

    <span class="cm">/* Each material is instantiated with its own constructor.
     * Here, the constructor argument defines number of unitcells.
     */</span>

    <span class="n">materials</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">CNT</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span> <span class="p">);</span> <span class="cm">/* CNT stands for Carbon Nanotube */</span>
    <span class="n">materials</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">Graphene</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="p">);</span>

    <span class="n">computeAlgorithm</span><span class="p">(</span><span class="n">materials</span><span class="p">);</span>

    <span class="cm">/* We should be able to do the same with some other algorithm 
     * on the same materials, if we would like. How nice?
     */</span>
<span class="p">}</span>
</code></pre></div></div> <p>Materials are defined like this. Note that material classes do not know anything about the operations that will be done on them, e.g. <em>computeStep1()</em> of the <em>Algorithm</em>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// materials.H</span>

<span class="cp">#include</span> <span class="cpf">"cnt.H"</span><span class="cp">
#include</span> <span class="cpf">"graphene.H"</span><span class="cp">
</span></code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// cnt.H (High level in terms of dependency)</span>

<span class="k">class</span> <span class="nc">CNT</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CNT</span><span class="p">(</span><span class="kt">int</span> <span class="n">uc</span><span class="p">)</span> <span class="o">:</span> <span class="n">_unitcells</span><span class="p">{</span><span class="n">uc</span><span class="p">}</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">get_unitcells</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_unitcells</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_unitcells</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>Implementations for these operations can be defined in separately, as follows. Here we define as free functions but they can be encapsulated in a namespace like AlgorithmSteps.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// materials_impl.H (Low level, implementation details)</span>

<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">CNT</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Graphene</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// cnt_impl.cpp</span>

<span class="cp">#include</span> <span class="cpf">"materials_impl.H

void computeStep1(CNT const&amp; cnt) {
    std::cout &lt;&lt; "</span><span class="c1">processing step 1 for CNT with unitcells: " &lt;&lt; cnt.get_unitcells() &lt;&lt; "\n";</span><span class="cp">
</span><span class="p">}</span>
</code></pre></div></div> <p>Finally, the Algorithm class is defined as follows, where all magic happens.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// algorithm.H (High level)</span>

<span class="cp">#include</span> <span class="cpf">"../materials/material.H"</span><span class="cp">
#include</span> <span class="cpf">"materials_impl.H"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Algorithm</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="cm">/* External polymorphism design pattern: allows C++ classes
     * unrelated by inheritance and/or having no virtual methods to be
     * created polymorphically.
     * We create a interface, AlgorithmConcept, and 
     * a derived class template, AlgorithmModel.
     * Algorithm model has a constructor that takes some T and uses it.
     */</span>
    <span class="k">struct</span> <span class="nc">AlgorithmConcept</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">AlgorithmConcept</span><span class="p">()</span> <span class="p">{}</span>
        
        <span class="cm">/* Steps of this algorithm concept, such as this,
         * are the affordances required by the derived class.
         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">computeStep1</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="cm">/* Prototype design pattern: clone function will return a copy of
         * whatever stored in the derived class in the form of a unique_ptr
         * to AlgorithmConcept.
         */</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">clone</span> <span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">AlgorithmModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AlgorithmConcept</span> <span class="p">{</span>
        <span class="n">AlgorithmModel</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">object</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)}</span> <span class="p">{}</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">AlgorithmModel</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="o">::</span><span class="n">computeStep1</span><span class="p">(</span><span class="n">object</span><span class="p">);</span> <span class="c1">// Affordances required by type T</span>
        <span class="p">}</span>
        
        <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="cm">/* if material implementations of computeStep1 are defined in free functions
     * we need a friend function here, which is injected in the namespace where
     * Algorithm is defined (in this case, global scope).
     */</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="p">);</span>

    <span class="cm">/* See that in the constructor, we store object we get as pointer to base.
     * That means we type erase T. T is only known in the constructor, and
     * that is why we need a base class AlgorithmConcept to store it in some form,
     * which in this case is a unique_ptr to base class.
     */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">pimpl</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* This templated constructor acts as a bridge:
     * It instantiates algorithm model for whatever T object you pass
     * and we store it as pointer to base so we have erased the type!!
     * We can have infinite number of derived classes but we dont have to
     * write them, the compiler will generate them for us!!
     */</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">pimpl</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">AlgorithmModel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">}</span> <span class="p">{}</span>

    <span class="cm">/* How to copy an object when we have erased the type of the object? 
     * Using clone functions! Prototype design pattern.
     */</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pimpl</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">pimpl</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// Reset pimpl to nullptr if 'that' has no pimpl</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Algorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
                <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">pimpl</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
                <span class="n">temp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Move constructor is straighforward to implement. */</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">Algorithm</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Algorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Algorithm</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">computeAlgorithm</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">materials</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// algorithm.cpp</span>

<span class="kt">void</span> <span class="nf">computeAlgorithm</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">materials</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cm">/* Polymorphism in action. 
     * step1 is executed for each material.
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="o">:</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">computeStep1</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cm">/* Actual computations are delegated to */</span>    
    <span class="n">material</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">computeStep1</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="workflow">Workflow</h4> <p>When computeStep1(material) is called in computeAlgorithm function above, it takes two indirections to execute computeStep1 for each material like CNT or Graphene. The first indirection happens at <em>computeStep1(Algorithm const&amp;)</em>, where a pimpl pointer calls <em>computeStep1()</em> overriden virtual function, which then calls <em>::computeStep1(object)</em> for a given object or material. Note that we could have also used a member function of object, instead of a free function, it is our choice. You can also support a capability where it can first look for a free function and if does not exist then use a member function.</p> <h4 id="more">More</h4> <p>For details, please refer to:</p> <ul> <li>Complete <a href="https://github.com/saurabh-s-sawant/cpp_exercises/tree/main/design/type_erasure" rel="external nofollow noopener" target="_blank">Code</a> described in this blog.</li> <li> <a href="https://www.youtube.com/watch?v=4eeESJQk-mw&amp;t=2889s" rel="external nofollow noopener" target="_blank">Breaking Dependencies: Type Erasure - A Design Analysis</a> by Klaus Iglberger (Absolutely amazing!)</li> <li> <a href="https://www.youtube.com/watch?v=qn6OqefuH08&amp;t=1381s" rel="external nofollow noopener" target="_blank">Breaking Dependencies - C++ Type Erasure - The Implementation Detail</a> by Klaus Iglberger (another relevant talk).</li> <li> <strong>Hands-On Design Patterns with C++</strong> by Fedor Pikus for details on type erasures.</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/policyBasedDesign/">Exploring Policy-Based Design : A Customizable Message Logger in C++</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/TMP/">Template Metaprogramming Practice Codes</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Saurabh S. Sawant. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>