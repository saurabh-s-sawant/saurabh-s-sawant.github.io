<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://saurabh-s-sawant.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://saurabh-s-sawant.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-26T05:02:50+00:00</updated><id>https://saurabh-s-sawant.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">C++ Template Basics</title><link href="https://saurabh-s-sawant.github.io/blog/2024/Templates/" rel="alternate" type="text/html" title="C++ Template Basics"/><published>2024-05-25T12:00:00+00:00</published><updated>2024-05-25T12:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/Templates</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/Templates/"><![CDATA[<h3 id="function-templates">Function Templates</h3> <table> <thead> <tr> <th style="text-align: left">Code</th> <th style="text-align: left"> </th> <th>Brief Information</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/function_templates/type_conversions/ex1.cpp">type_conversion</a></td> <td style="text-align: left"> </td> <td>Type conversion during argument type deduction. Use of <code class="language-plaintext highlighter-rouge">&lt;boost/type_index.hpp&gt;</code>.</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/function_templates/return_type_for_multiple_template_params/ex1.cpp">return_type_deduction</a></td> <td style="text-align: left"> </td> <td>Three ways to deduce return type in a template functions, differences in C++11, 14, 17</td> </tr> </tbody> </table> <p><br/></p> <h3 id="class-templates">Class Templates</h3> <table> <thead> <tr> <th style="text-align: left">Code</th> <th style="text-align: left"> </th> <th>Brief Information</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/class_templates/friend/ex1_template_entity.cpp">template_entity</a></td> <td style="text-align: left"> </td> <td>What is template entity? – an ordinary function instantiated with a class template.</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/class_templates/friend/ex2_nonmember_function_template.cpp">nonmember_FT</a></td> <td style="text-align: left"> </td> <td>How to declare a template entity? – implicity declaration of new function template</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/class_templates/friend/ex3_forward_declare_function_template.cpp">forward_declare_FT</a></td> <td style="text-align: left"> </td> <td>How to declare a template entity? – forward declaration of FT for the class and inside the class declare specialization of nonmember function template</td> </tr> </tbody> </table> <p><br/></p> <h3 id="variadic-templates">Variadic Templates</h3> <table> <thead> <tr> <th style="text-align: left">Code</th> <th style="text-align: left"> </th> <th>Brief Information</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/templates/variadic_templates/example1.cpp">example1</a></td> <td style="text-align: left"> </td> <td>Simple recursive print function. Difference in using <code class="language-plaintext highlighter-rouge">sizeof...</code>operator with regular if versus compile-time if.</td> </tr> </tbody> </table> <p><br/> More examples with detailed comments will be added in time.</p> <h4 id="references">References</h4> <ul> <li><a href="https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121">C++ Templates: The Complete Guide (second ed.)</a> by Vandevoorde D., Josuttis N., Gregor D.</li> <li><a href="https://www.youtube.com/watch?v=HqsEHG0QJXU&amp;t=11s">Back to Basics: Templates in C++</a> by Nicolai Josuttis.</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="C++"/><category term="templates"/><summary type="html"><![CDATA[This covers basics of templates including function templates, class templates, variadic templates, non-type template parameters, and more.]]></summary></entry><entry><title type="html">Just-In-Time Compiled CUDA Kernel</title><link href="https://saurabh-s-sawant.github.io/blog/2024/GPU-JIT/" rel="alternate" type="text/html" title="Just-In-Time Compiled CUDA Kernel"/><published>2024-05-20T12:00:00+00:00</published><updated>2024-05-20T12:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/GPU-JIT</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/GPU-JIT/"><![CDATA[<h3 id="overview">Overview</h3> <p>Just-in-Time (JIT) compilation is a powerful tool for developers aiming to optimize applications dynamically. With this technique, compilation of the code can be deferred to runtime rather than ahead-of-time (AoT). Here I explore the use of NVIDIA’s NVRTC runtime compilation library to JIT-compile a simple CUDA kernel for vector addition. With this technique, we can alter CUDA code dynamically based on run-time conditions.</p> <h3 id="why-to-use-jit-in-cuda">Why to Use JIT in CUDA?</h3> <ul> <li>On-the-fly generation of CUDA kernels based on configuration at run-time</li> <li>Optimization of kernel for specific GPU architecture</li> <li>Testing without the overhead of recompiling the whole program after every change</li> </ul> <h3 id="example-vector-addition">Example: Vector Addition</h3> <p>Code is available at <a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/jit_nvrtc/vector_add/vectorAdd_JIT.cu">vector_add_JIT.cu</a>. Major components of the code are described below.</p> <h4 id="kernel-code-as-string">Kernel code as string</h4> <p>NVRTC requires CUDA kernel written as string. Here is the simple kernel to add two vectors and store it in a third vector.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cudaKernelCode</span> <span class="o">=</span> <span class="s">R"(
extern "C"
__global__ void vectorAdd(const float* A, const float* B, float* C, int N) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx &lt; N) {
        C[idx] = A[idx] + B[idx];
    }
}
)"</span><span class="p">;</span>
</code></pre></div></div> <h4 id="compilation">Compilation</h4> <p>Compile the kernel using NVRTC. <code class="language-plaintext highlighter-rouge">options</code> is a vector that reads in the compilation flags passed as arguments at run-time.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Use NVRTC to compile the kernel</span>
    <span class="n">nvrtcProgram</span> <span class="n">prog</span><span class="p">;</span>
    <span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcCreateProgram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prog</span><span class="p">,</span> <span class="n">cudaKernelCode</span><span class="p">,</span> <span class="s">"vectorAdd.cu"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>

    <span class="c1">// Compile the kernel</span>
    <span class="n">nvrtcResult</span> <span class="n">compileResult</span> <span class="o">=</span> <span class="n">nvrtcCompileProgram</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">options</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
</code></pre></div></div> <h4 id="generation-of-ptx">Generation of PTX</h4> <p>Generate PTX code. Optionally, write it to a file for analysis.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Obtain the PTX from the program</span>
    <span class="kt">size_t</span> <span class="n">ptxSize</span><span class="p">;</span>
    <span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTXSize</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptxSize</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ptx</span><span class="p">(</span><span class="n">ptxSize</span><span class="p">);</span>
    <span class="n">NVRTC_SAFE_CALL</span><span class="p">(</span><span class="n">nvrtcGetPTX</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">ptx</span><span class="p">.</span><span class="n">data</span><span class="p">()));</span>

    <span class="c1">//...</span>

    <span class="n">ptxFile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ptx</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ptx</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div></div> <h4 id="execution">Execution</h4> <p>Load the compiled kernel and execute it on GPU.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Load the PTX and get the kernel handle</span>
    <span class="n">CUmodule</span> <span class="k">module</span><span class="p">;</span>
    <span class="n">CUfunction</span> <span class="n">kernel</span><span class="p">;</span>
    <span class="n">CU_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleLoadData</span><span class="p">(</span><span class="o">&amp;</span><span class="k">module</span><span class="p">,</span> <span class="n">ptx</span><span class="p">.</span><span class="n">data</span><span class="p">()));</span>
    <span class="n">CU_SAFE_CALL</span><span class="p">(</span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kernel</span><span class="p">,</span> <span class="k">module</span><span class="p">,</span> <span class="s">"vectorAdd"</span><span class="p">));</span>

    <span class="c1">// Launch the kernel</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">d_A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_B</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_C</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">threadsPerBlock</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">blocksPerGrid</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">threadsPerBlock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threadsPerBlock</span><span class="p">;</span>
    <span class="n">CU_SAFE_CALL</span><span class="p">(</span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">blocksPerGrid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">threadsPerBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</code></pre></div></div> <h4 id="compile-and-run">Compile and Run</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvcc vectorAdd_JIT.cu -o solver.x -lnvrtc -lcuda -std=c++14
</code></pre></div></div> <h3 id="analysis">Analysis</h3> <p>Let’s run the code with and without passing the argument <code class="language-plaintext highlighter-rouge">--use_fast_math</code> and compare whether the JIT-compiled code generates a different assembly code at run time. This flag replaces certain floating point operations with faster versions that may be less accurate for efficiency.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/gpu_jit/jit_ptx_diff-480.webp 480w,/assets/img/posts/gpu_jit/jit_ptx_diff-800.webp 800w,/assets/img/posts/gpu_jit/jit_ptx_diff-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/posts/gpu_jit/jit_ptx_diff.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="example image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> <div align="justify"> Output of vimdiff command on ptx generated without (left) and with --use_fast_math flag (right). </div></div> <p>From the figure above, we see the difference in assembly at an instruction where two floating points in <code class="language-plaintext highlighter-rouge">%f2</code> and <code class="language-plaintext highlighter-rouge">%f1</code> registers are added and stored in <code class="language-plaintext highlighter-rouge">%f3</code> register.</p> <p>The <code class="language-plaintext highlighter-rouge">ftz</code> qualifier stands for Flust To Zero, which affects how the instruction handles very small numbers close to zero, known as subnormal numbers. (When the result of a computation is too small to be represented as a normal floating-point number (given the constraints of the exponent and mantissa), it can be represented as a subnormal number. In subnormal numbers, the leading bit of the mantissa is zero instead of one, allowing for the representation of numbers closer to zero than would otherwise be possible. This is done at the cost of precision).</p> <p>The <code class="language-plaintext highlighter-rouge">ftz</code> mode ensures subnormal numbers are treated as zero, which may prevent performance penalties arising from handling denormalized numbers.</p> <h3 id="references">References</h3> <ul> <li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#driver-api">CUDA Driver API</a></li> <li><a href="https://en.wikipedia.org/wiki/Subnormal_number">Subnormal numbers</a></li> </ul>]]></content><author><name></name></author><category term="code"/><category term="gpu"/><category term="JIT"/><summary type="html"><![CDATA[Using NVRTC library to compile a CUDA kernel just-in-time, allowing you to dynamically adjust compiler settings based on run-time conditions.]]></summary></entry><entry><title type="html">GPU Practice Codes</title><link href="https://saurabh-s-sawant.github.io/blog/2024/GPU/" rel="alternate" type="text/html" title="GPU Practice Codes"/><published>2024-05-19T12:00:00+00:00</published><updated>2024-05-19T12:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/GPU</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/GPU/"><![CDATA[<p>Practice GPU kernels with CUDA for common operations.</p> <table> <thead> <tr> <th style="text-align: left">Code</th> <th style="text-align: left"> </th> <th style="text-align: left">Preprocessor Flags</th> <th> </th> <th>Brief description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/matrix_mult/matmul.cu">matrix multiplication</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, high latency</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED</code></td> <td> </td> <td>2D tiling</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED_COARSENED</code></td> <td> </td> <td>2D tiling + thread coarsening</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/convolution/convolution.cu">convolution</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, high latency</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">CONSTMEM</code></td> <td> </td> <td>constant memory for filter</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED_CONSTANTMEM_TYPE_1</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">CONSTMEM</code> + 2D tiling with more threads than output tile</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED_CONSTANTMEM_TYPE_2</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">CONSTMEM</code> + 2D tiling with fewer threads than input tile</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED_CONSTANTMEM_CACHEHALO</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">TILED_CONSTANTMEM_TYPE_2</code> with halo cells loaded from memory (L2 cache)</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/transpose/transpose.cu">transpose</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, thread coarsening, high latency</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">CORNER_TURNING</code></td> <td> </td> <td>thread coarsening + tiling with corner turning</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NO_BANK_CONFLICT</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">CORNER_TURNING</code> without bank conflicts</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/image_rotation/image_rotate.cu">image rotation</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, thread coarsening, high latency</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">CORNER_TURNING</code></td> <td> </td> <td>thread coarsening + similar to corner turning without bank conflicts</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/stencil/stencil.cu">stencil (need cleanup)</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, high latency</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TILED</code></td> <td> </td> <td>2D tiling</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">THREADCOARSENING</code></td> <td> </td> <td>2D tiling + thread coarsening</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">REGISTERTILING_THREADCOARSENING</code></td> <td> </td> <td>2D tiling with smart use of registers</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/streams/streams.cu">streams</a></td> <td style="text-align: left"> </td> <td style="text-align: left">-</td> <td> </td> <td>overlapping kernel with cudaMemcpyAsync</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/histogram/histogram.cu">histogram</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, high contention</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">PRIVATIZATION</code></td> <td> </td> <td>privatization to reduce contention</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">THREADCOARSENING_CONTIGUOUS</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">PRIVATIZATION</code> + threadcoarsening with contiguous accesses per thread</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">THREADCOARSENING_INTERLEAVED</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">PRIVATIZATION</code> + threadcoarsening with interleaved accesses for better memory coalescing</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">AGGREGATION</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">THREADCOARSENING_INTERLEAVED</code> + with accumulator (best for non-uniform distribution of data)</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/reduction/reduction.cu">reduction</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">NAIVE</code></td> <td> </td> <td>simplest, single block, control divergence</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">CONVERGENT</code></td> <td> </td> <td>single block, no control divergence</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">SHAREDMEM</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">CONVERGENT</code> + use of shared memory</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">HIERARCHICAL</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">SHAREDMEM</code> + multiple blocks per grid</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">THREADCOARSENING</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">HIERARCHICAL</code> + thread coarsening</td> </tr> <tr> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/gpu_exer/blob/main/practice_codes/prefix_sum/prefixsum.cu">prefix sum</a></td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">KOGG_STONE</code></td> <td> </td> <td>Kogg-Stone algorithm</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">KOGG_STONE_DOUBLE_BUFFER</code></td> <td> </td> <td><code class="language-plaintext highlighter-rouge">KOGG_STONE</code> with double buffering technique</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BRENT_KUNG</code></td> <td> </td> <td>Brent-Kung algorithm</td> </tr> </tbody> </table> <p><br/> More example will be added in time.</p> <h4 id="references">References</h4> <ul> <li><a href="https://www.amazon.com/Programming-Massively-Parallel-Processors-Hands/dp/0323912311">Programming Massively Parallel Processors: A Hands-On Approach (4th edn.)</a> by Wen-mei W. Hwu, David B. Kirk, Izzat El Hajj</li> <li><a href="https://www.olcf.ornl.gov/cuda-training-series/">CUDA Training Series</a> organized by NVIDIA and Oak Ridge National Laboratory</li> <li>NVIDIA blogs</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="gpu"/><summary type="html"><![CDATA[Practice GPU kernels with CUDA for common operations.]]></summary></entry><entry><title type="html">Template Metaprogramming Practice Codes</title><link href="https://saurabh-s-sawant.github.io/blog/2024/TMP/" rel="alternate" type="text/html" title="Template Metaprogramming Practice Codes"/><published>2024-05-04T12:00:00+00:00</published><updated>2024-05-04T12:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/TMP</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/TMP/"><![CDATA[<table> <thead> <tr> <th style="text-align: left">Ex.</th> <th style="text-align: left"> </th> <th style="text-align: left">Code</th> <th> </th> <th>What I learned?</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td style="text-align: left"> </td> <td style="text-align: left"><a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/TMP/simple_type_traits/ex1.cpp">simplest metaprogram with type_traits</a></td> <td> </td> <td>How <code class="language-plaintext highlighter-rouge">std::is_pointer&lt;T&gt;::value</code> works. How to take template argument <code class="language-plaintext highlighter-rouge">T</code> and strip off any pointer if it has one. Compile-time <code class="language-plaintext highlighter-rouge">if-else</code>.</td> </tr> <tr> <td style="text-align: left">2</td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td> </td> <td> </td> </tr> </tbody> </table> <p>I will add more examples in time.</p> <h4 id="references">References</h4> <ul> <li><a href="https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121">C++ Templates: The Complete Guide (second ed.)</a> by Vandevoorde, Josuttis, Gregor</li> <li><a href="https://www.youtube.com/@bitsofq">BitsOfQ</a> C++ Template Metaprogramming playlist by Quirijn</li> <li><a href="https://www.youtube.com/watch?v=tiAVWcjIF6o">Template Metaprogramming (part 1 &amp; 2)</a> in CppCon by Jody Hagins</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="TMP"/><category term="C++"/><summary type="html"><![CDATA[Basic examples to familiarize oneself with TMP.]]></summary></entry><entry><title type="html">Exploring Type Erasure as a Design Pattern: A Generic Materials Solver</title><link href="https://saurabh-s-sawant.github.io/blog/2024/typeErasure/" rel="alternate" type="text/html" title="Exploring Type Erasure as a Design Pattern: A Generic Materials Solver"/><published>2024-03-16T16:00:00+00:00</published><updated>2024-03-16T16:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/typeErasure</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/typeErasure/"><![CDATA[<p><span style="font-size: larger;"><b><strong>Problem Statement / Motivation</strong></b></span><br/> Consider this problem: we want to design a materials solver that computes the transport of electrons through different materials. Let’s say we opt for a super accurate numerical method, like quantum transport based on Schrodinger’s equation.</p> <p>This method involves many steps and details, and we want our code to handle various materials. Implementing the method for each material could vary depending on the material’s data structure and physics. So, how should we design this code?</p> <p>My initial thought is to use inheritance — have a base class defining an interface for the algorithm, with some default implementations that derived material classes can override. The base class can be a template class where the template parameter defines the relevant data structure, and the materials are specializations of this class template. We can store instantiated materials as pointers to the base class and use dynamic polymorphism to perform the algorithm. Although there are more nuances to this setup, let’s keep it simple. This design allows for extending to different materials as well as modeling multiple copies of a given material together.</p> <p>However, what if there are multiple possible implementations for one of the steps of the algorithm? Creating another derived class for each material isn’t viable, as it leads to an intractably deep inheritance hierarchy, too many derived classes, and duplication.</p> <p>The typical, well-tested solution to this problem is the Strategy Design Pattern, as explained in the Gang of Four book, or described beautifully on <a href="https://refactoring.guru/design-patterns/catalog">refactoring.guru</a>.</p> <p>The Strategy design pattern abstracts implementation details into a strategy for executing a particular operation, such as step 1 of the algorithm. This operation can have multiple implementations without modifying the base class. This allows us to interchange the object for implementing the operation at runtime. This design results in three architectural levels: high-level, composed of the base class defining the algorithm’s interface; intermediate level, where we define different materials and corresponding strategies for their operations; and the low level, which contains all implementation details such as concrete strategies.</p> <p>However, what if someone else on our team wants to develop a different, perhaps lower-fidelity numerical method (e.g., a Boltzmann transport method) for material transport, also capable of handling different materials within the same general framework for material transport?</p> <p>Clearly, we don’t want material classes to depend on a particular method defined previously as the base class. If we do that, we’ll end up duplicating a good chunk of the code that defines material characteristics.</p> <p>So, what is the best design to handle this?</p> <p>Thankfully, a few months ago, I discovered Klaus Iglberger on the internet through his engaging lectures at CppCon. In his lecture, “<a href="https://www.youtube.com/watch?v=4eeESJQk-mw&amp;t=2889s">Breaking Dependencies: Type Erasure - A Design Analysis</a>,” he described the use of type erasure as a design pattern. He used an example of shapes to illustrate this pattern, which combines three design patterns: external polymorphism, bridge, and prototype, to achieve something remarkable.</p> <p>His example of shapes resonated a lot with the materials problem I described above, and more importantly, the problem we all encounter a lot in scientific code development: dealing with dependencies. Code components become too coupled to each other for any meaningful extension to happen without breaking the Open/Closed principle.</p> <p>Following his video, here is the dummy code I wrote. If I had come across this two years ago, I would have made different decisions in my own development. But hey, there will be many opportunities to code. So, I consider myself fortunate to have come across this. I hope you do too.</p> <p>(On a side note) Althogh the Devin AI is learning to code, I highly doubt it would discover such design strategies on its own. So, the idea of AI replacing developers remains more of a wishlist for now.</p> <p><span style="font-size: larger;"><b><strong>Type Erasure in Action</strong></b></span><br/> I would jump straight to main() and demonstrate what we can do with type erasures. I can define a vector of materials that follow the steps of my particular algorithm, execute these steps polymorphically (that’s what external polymorphism let’s you do), completely decouple material details from the operations that may be performed on the material, and have flexibility for multiple implementations of those operations.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"materials/materials.H"</span><span class="cp">
#include</span> <span class="cpf">"algorithm_impl/algorithm.H"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="cm">/* Materials that we would Algorithm to be executed */</span>
    <span class="k">using</span> <span class="n">Materials</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">Materials</span> <span class="n">materials</span><span class="p">;</span>

    <span class="cm">/* Each material is instantiated with its own constructor.
     * Here, the constructor argument defines number of unitcells.
     */</span>

    <span class="n">materials</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">CNT</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span> <span class="p">);</span> <span class="cm">/* CNT stands for Carbon Nanotube */</span>
    <span class="n">materials</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">Graphene</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="p">);</span>

    <span class="n">computeAlgorithm</span><span class="p">(</span><span class="n">materials</span><span class="p">);</span>

    <span class="cm">/* We should be able to do the same with some other algorithm 
     * on the same materials, if we would like. How nice?
     */</span>
<span class="p">}</span>
</code></pre></div></div> <p>Materials are defined like this. Note that material classes do not know anything about the operations that will be done on them, e.g. <em>computeStep1()</em> of the <em>Algorithm</em>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// materials.H</span>

<span class="cp">#include</span> <span class="cpf">"cnt.H"</span><span class="cp">
#include</span> <span class="cpf">"graphene.H"</span><span class="cp">
</span></code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// cnt.H (High level in terms of dependency)</span>

<span class="k">class</span> <span class="nc">CNT</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">CNT</span><span class="p">(</span><span class="kt">int</span> <span class="n">uc</span><span class="p">)</span> <span class="o">:</span> <span class="n">_unitcells</span><span class="p">{</span><span class="n">uc</span><span class="p">}</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">get_unitcells</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_unitcells</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_unitcells</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>Implementations for these operations can be defined in separately, as follows. Here we define as free functions but they can be encapsulated in a namespace like AlgorithmSteps.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// materials_impl.H (Low level, implementation details)</span>

<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">CNT</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Graphene</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// cnt_impl.cpp</span>

<span class="cp">#include</span> <span class="cpf">"materials_impl.H

void computeStep1(CNT const&amp; cnt) {
    std::cout &lt;&lt; "</span><span class="c1">processing step 1 for CNT with unitcells: " &lt;&lt; cnt.get_unitcells() &lt;&lt; "\n";</span><span class="cp">
</span><span class="p">}</span>
</code></pre></div></div> <p>Finally, the Algorithm class is defined as follows, where all magic happens.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// algorithm.H (High level)</span>

<span class="cp">#include</span> <span class="cpf">"../materials/material.H"</span><span class="cp">
#include</span> <span class="cpf">"materials_impl.H"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Algorithm</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="cm">/* External polymorphism design pattern: allows C++ classes
     * unrelated by inheritance and/or having no virtual methods to be
     * created polymorphically.
     * We create a interface, AlgorithmConcept, and 
     * a derived class template, AlgorithmModel.
     * Algorithm model has a constructor that takes some T and uses it.
     */</span>
    <span class="k">struct</span> <span class="nc">AlgorithmConcept</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">AlgorithmConcept</span><span class="p">()</span> <span class="p">{}</span>
        
        <span class="cm">/* Steps of this algorithm concept, such as this,
         * are the affordances required by the derived class.
         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">computeStep1</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="cm">/* Prototype design pattern: clone function will return a copy of
         * whatever stored in the derived class in the form of a unique_ptr
         * to AlgorithmConcept.
         */</span>
        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">clone</span> <span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">AlgorithmModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AlgorithmConcept</span> <span class="p">{</span>
        <span class="n">AlgorithmModel</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">object</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)}</span> <span class="p">{}</span>
        
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">AlgorithmModel</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
            <span class="o">::</span><span class="n">computeStep1</span><span class="p">(</span><span class="n">object</span><span class="p">);</span> <span class="c1">// Affordances required by type T</span>
        <span class="p">}</span>
        
        <span class="n">T</span> <span class="n">object</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="cm">/* if material implementations of computeStep1 are defined in free functions
     * we need a friend function here, which is injected in the namespace where
     * Algorithm is defined (in this case, global scope).
     */</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="p">);</span>

    <span class="cm">/* See that in the constructor, we store object we get as pointer to base.
     * That means we type erase T. T is only known in the constructor, and
     * that is why we need a base class AlgorithmConcept to store it in some form,
     * which in this case is a unique_ptr to base class.
     */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AlgorithmConcept</span><span class="o">&gt;</span> <span class="n">pimpl</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="cm">/* This templated constructor acts as a bridge:
     * It instantiates algorithm model for whatever T object you pass
     * and we store it as pointer to base so we have erased the type!!
     * We can have infinite number of derived classes but we dont have to
     * write them, the compiler will generate them for us!!
     */</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">args</span><span class="p">)</span> <span class="o">:</span> <span class="n">pimpl</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">AlgorithmModel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="p">}</span> <span class="p">{}</span>

    <span class="cm">/* How to copy an object when we have erased the type of the object? 
     * Using clone functions! Prototype design pattern.
     */</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pimpl</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">pimpl</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">// Reset pimpl to nullptr if 'that' has no pimpl</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">Algorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
                <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">pimpl</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
                <span class="n">temp</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Move constructor is straighforward to implement. */</span>
    <span class="n">Algorithm</span><span class="p">(</span><span class="n">Algorithm</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Algorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Algorithm</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">computeAlgorithm</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">materials</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// algorithm.cpp</span>

<span class="kt">void</span> <span class="nf">computeAlgorithm</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">materials</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cm">/* Polymorphism in action. 
     * step1 is executed for each material.
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="o">:</span> <span class="n">materials</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">computeStep1</span><span class="p">(</span><span class="n">material</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">computeStep1</span><span class="p">(</span><span class="n">Algorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">material</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cm">/* Actual computations are delegated to */</span>    
    <span class="n">material</span><span class="p">.</span><span class="n">pimpl</span><span class="o">-&gt;</span><span class="n">computeStep1</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="workflow">Workflow</h4> <p>When computeStep1(material) is called in computeAlgorithm function above, it takes two indirections to execute computeStep1 for each material like CNT or Graphene. The first indirection happens at <em>computeStep1(Algorithm const&amp;)</em>, where a pimpl pointer calls <em>computeStep1()</em> overriden virtual function, which then calls <em>::computeStep1(object)</em> for a given object or material. Note that we could have also used a member function of object, instead of a free function, it is our choice. You can also support a capability where it can first look for a free function and if does not exist then use a member function.</p> <h4 id="more">More</h4> <p>For details, please refer to:</p> <ul> <li>Complete <a href="https://github.com/saurabh-s-sawant/cpp_exercises/tree/main/design/type_erasure">Code</a> described in this blog.</li> <li><a href="https://www.youtube.com/watch?v=4eeESJQk-mw&amp;t=2889s">Breaking Dependencies: Type Erasure - A Design Analysis</a> by Klaus Iglberger (Absolutely amazing!)</li> <li><a href="https://www.youtube.com/watch?v=qn6OqefuH08&amp;t=1381s">Breaking Dependencies - C++ Type Erasure - The Implementation Detail</a> by Klaus Iglberger (another relevant talk).</li> <li><strong>Hands-On Design Patterns with C++</strong> by Fedor Pikus for details on type erasures.</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="design_patterns"/><category term="C++"/><summary type="html"><![CDATA[Exploring possibility of using type erasure as a design pattern through an example of a generic materials solver.]]></summary></entry><entry><title type="html">Exploring Policy-Based Design: A Customizable Message Logger in C++</title><link href="https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign/" rel="alternate" type="text/html" title="Exploring Policy-Based Design: A Customizable Message Logger in C++"/><published>2024-02-04T20:00:00+00:00</published><updated>2024-02-04T20:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign/"><![CDATA[<p>Policy-based design is a versatile design pattern that underpins many useful features in modern C++, such as smart pointers. Despite its resourcefulness, I never delved into it during my work developing scientific codes.Intrigued by its potential, I decided to explore its application by creating a simple message logger that could be customized to suit user needs. <a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/design/policy_based_design/ex1_msglogger.cpp">Here</a> is the github link to the code.</p> <p>Before diving into the specifics, let’s review the context in which this design pattern shines.</p> <h3 id="overview">Overview</h3> <p>Policy-based design serves as a compile-time counterpart to the well-known strategy pattern. It may be useful in scenarios where when we know the desired behavior (‘what’), but do not know a single, definitive implementation (‘how’). In essence, it allows for multiple ‘how’ implementations, offering flexibility for possible future enhancements or changes in requirements.</p> <p>This decoupling of desired behavior and implementation details enables developers to define various policies at compile-time, dictating different behaviors of a class. This approach provides a high degree of customization and adaptability, exemplified by features such as ‘std::unique_ptr’ allowing users to define custom deleters.</p> <h3 id="example-description">Example Description</h3> <p>Imagine we are developing a complex code, and we require an extensive logger to track the execution flow and to diagnose issues. We would like a message logger that can:</p> <ul> <li>direct messages to different destinations such as console or a user-defined file</li> <li>prepend the log message with some message stamp, such as a timestamp or a process id</li> <li>allow users to pass custom callables for logging special data types or performing additional tasks</li> </ul> <h3 id="implementation-policies">Implementation Policies</h3> <p>To achive these objectives, we will create ‘MsgLogger’ class with the following policies:</p> <ol> <li>StreamPolicy: dictates where the log messages will be directed. Implementations: <ul> <li>WriteToConsole: sends messages to the console.</li> <li>WriteToFile: writes messages to a file (with support for thread safety).</li> </ul> </li> <li>StampPolicy: controls the formatting of prepended message stamps. <ul> <li>NoStamp: opts for no stamp inclusion.</li> <li>WithStamp_TimeSecPrecis: prepends a timestamp to each log message.</li> <li>WithStamp_TimeMicroSecPrecis: prepends a timestamp with microsecond precision.</li> </ul> </li> <li>CallablePolicy: determines whether a callable can be passed to the logger object. <ul> <li>NoCallable: opts not to support a callable.</li> <li>WithCallable: allows users to pass a user-defined callable such as a lambda function.</li> </ul> </li> </ol> <h3 id="implementation-details">Implementation Details</h3> <p>The ‘MsgLogger’ logger class combines these policies to offer a flexible solution. Users can combine these policies according to their need or add new implementations of these policies independently, making code reusable and maintainable.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">StreamPolicy</span><span class="o">=</span><span class="n">WriteToConsole</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">StampPolicy</span><span class="o">=</span><span class="n">NoStamp</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">CallablePolicy</span><span class="o">=</span><span class="n">NoCallable</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MsgLogger</span> <span class="o">:</span> <span class="k">private</span> <span class="n">StreamPolicy</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/* Preference for r-value references.
     * l-value strings must be moved while passing as arguments.
     */</span>
    <span class="k">explicit</span> <span class="n">MsgLogger</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">init_msg</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span> 
                       <span class="n">StreamPolicy</span><span class="o">&amp;&amp;</span> <span class="n">stream_policy</span> <span class="o">=</span> <span class="n">StreamPolicy</span><span class="p">())</span> <span class="o">:</span>
    <span class="n">StreamPolicy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">stream_policy</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">StampPolicy</span><span class="o">::</span><span class="n">get_stamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">init_msg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*default F is an empty function */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()&gt;,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="o">=</span><span class="p">{},</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">callable_duration</span><span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{};</span>

        <span class="c1">//forward callable signature and arguments</span>
        <span class="n">CallablePolicy</span><span class="o">::</span><span class="n">call</span><span class="p">(</span><span class="n">callable_duration</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> 
                                                <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="n">StampPolicy</span><span class="o">::</span><span class="n">get_stamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">callable_duration</span><span class="p">);</span>
    <span class="p">}</span>

   <span class="o">~</span><span class="n">MsgLogger</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">//non-copyable</span>
    <span class="n">MsgLogger</span><span class="p">(</span><span class="k">const</span> <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="c1">//movable, let's say</span>
    <span class="n">MsgLogger</span><span class="p">(</span><span class="n">MsgLogger</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">StreamPolicy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">))</span> <span class="p">{}</span>

    <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MsgLogger</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>In our design, StreamPolicy is inherited by MsgLogger instead of composed. This choice of inheritance, marked as private, emphasizes that MsgLogger is not a StreamPolicy but is only implemented-in-terms-of it.</p> <p>For instance, the simplest StreamPolicy, WriteToConsole, is defined as follows:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WriteToConsole</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>Inheriting StreamPolicy offers an advantange when the base class, such as WriteToConsole, has no data members. In such cases, compilers optimize the size of the derived class object (MsgLogger object) through ‘empty base class optimization’.</p> <p>A simple ‘WithStamp_TimeMicroSecPrecis’ policy is given below:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WithStamp_TimeMicroSecPrecis</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_stamp</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="kt">uint64_t</span> <span class="n">micros_since_epoch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()).</span><span class="n">count</span><span class="p">();</span>

        <span class="k">auto</span> <span class="n">microseconds</span> <span class="o">=</span> <span class="n">micros_since_epoch</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">time_now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_now</span><span class="p">),</span> <span class="s">"%T"</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">microseconds</span><span class="p">;</span>
        <span class="k">return</span> <span class="s">"["</span> <span class="o">+</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">+</span> <span class="s">"] "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This policy is stateless, as it doesn’t require any data members. Additionally, the ‘get_timestamp’ function operates independently of the message logger object, allowing us to use it statically without the need to store it within the MsgLogger class.</p> <p>The ‘WithCallable’ policy is outlined below:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WithCallable</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()&gt;,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="o">=</span><span class="p">{},</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//convert func to std::function object and test</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="cm">/* func can be invoked.
             * measure duration, output as string.
             */</span>
            <span class="k">auto</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

            <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

            <span class="k">auto</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">time_elapsed</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span>
                                <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">);</span>

            <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
            <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">time_elapsed</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="s">" Time taken: "</span> <span class="o">+</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">+</span> <span class="s">" micro-sec.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* func is empty
             * attempting to invoke func will result in std::bad_function_call
             */</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This implementation allows for invoking the forwarded callable and measuring its time. Additionally, it checks if ‘func’ is empty to handle cases where no callable is provided.</p> <h3 id="demonstration">Demonstration</h3> <p>Let’s demonstrate how to use the ‘MsgLogger’ class with different combinations of policies.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//default logger</span>
    <span class="n">MsgLogger</span> <span class="n">logger</span><span class="p">(</span><span class="s">"Hello, this is default  logger!"</span><span class="p">);</span>
    <span class="n">logger</span><span class="p">(</span><span class="s">"default logger is logging..."</span><span class="p">);</span>

    <span class="c1">//file logger without callable</span>
    <span class="n">MsgLogger</span><span class="o">&lt;</span><span class="n">WriteToFile</span><span class="p">,</span> <span class="n">WithStamp_TimeMicroSecPrecis</span><span class="o">&gt;</span>
        <span class="n">file_logger</span><span class="p">{</span><span class="s">"Hello, this is file_logger!"</span><span class="p">,</span> <span class="n">WriteToFile</span><span class="p">(</span><span class="s">"file.dat"</span><span class="p">)};</span>
    <span class="n">file_logger</span><span class="p">(</span><span class="s">"file_logger is logging..."</span><span class="p">);</span>

    <span class="c1">//file logger with callable</span>
    <span class="n">MsgLogger</span><span class="o">&lt;</span><span class="n">WriteToFile</span><span class="p">,</span> <span class="n">WithStamp_TimeMicroSecPrecis</span><span class="p">,</span> <span class="n">WithCallable</span><span class="o">&gt;</span> <span class="n">callable_logger</span>
    <span class="p">{</span><span class="s">"Hello, I am callable_logger!"</span><span class="p">,</span> <span class="n">WriteToFile</span><span class="p">(</span><span class="s">"file.dat"</span><span class="p">)};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">complex_vec</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">log_vector</span><span class="p">(</span><span class="n">callable_logger</span><span class="p">,</span> <span class="n">complex_vec</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>where ‘log_vector’ is:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LoggerType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">VecType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">log_vector</span><span class="p">(</span><span class="n">LoggerType</span><span class="o">&amp;</span> <span class="n">logger</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VecType</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">logger</span><span class="p">(</span><span class="s">"Vector is printed! "</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>    
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="o">:</span> <span class="n">vec</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
            <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">" vec["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]: "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">real</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">imag</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span><span class="p">;</span>
            <span class="n">logger</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>The output written to console reads:</p> <pre><code class="language-dat">
Hello, this is default  logger!
default logger is logging...
</code></pre> <p>The output written to ‘file.dat’ reads:</p> <pre><code class="language-dat">
[10:28:07.134316] Hello, I am callable_logger!
[10:28:07.134321]  vec[0]: 1 + 2i
[10:28:07.134322]  vec[1]: 3 + 4i
[10:28:07.134324]  vec[2]: 5 + 6i
[10:28:07.134326] Vector is printed!  Time taken: 5 micro-sec.


[10:28:07.134284] Hello, this is file_logger!
[10:28:07.134306] file_logger is logging...
</code></pre> <h3 id="further-exploration">Further Exploration</h3> <p>We have only scratched the surface of the power of this design pattern. Policies can extend beyond simple function objects and include template instantiations or even templates themselves. Additionally, policy classes can be composed rather than inherited, which is useful if policies hold a state and need to be stored in the policy class.</p> <p>Combining policy-based design with the Curiously Recurring Template Pattern (CRTP) allows for modifications to the public interface of a class. Moreover, this pattern can be leveraged to create policies for writing unit tests, enabling robust testing strategies.</p> <p>An interesting application of policy-based design involves combining it with the type-erasure technique to unify different customized instances of the policy class into a single type, as seen in std::shared_ptr.</p> <p>However, it’s important to note a major criticism of this design pattern. When dealing with many policies, specifying a non-default policy towards the end of a long policy list requires declaring all policies before it. While this challenge can be mitigated by organizing policies thoughtfully and using policy adapters with aliases, it is worth considering in other possible design patterns that may be used instead.</p> <p>For further exploration and reading, please refer to:</p> <ul> <li><strong>Hands-On Design Patterns with C++</strong> by Fedor Pikus</li> <li><strong>Modern C++ Design: Generic Programming and Design Patterns Applied</strong> by Andrei Alexandrescu</li> <li><a href="https://www.youtube.com/watch?v=fauJG1WEDUM">Policy-based design in C++20</a> by Goran Arandjelović on Youtube</li> <li><a href="https://www.foonathan.net/2017/02/policy-based-design-problem/">The problem with policy-based design</a> by Jonathan Müller</li> <li><a href="https://stackoverflow.com/questions/20276659/policy-based-approach-with-logger">Policy based approach with logger</a> on stackoverflow</li> <li><strong>ChatGPT</strong> (with a grain of salt)</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="design_patterns"/><category term="C++"/><category term="TMP"/><summary type="html"><![CDATA[Message logger offers three policies&#58; directing log messages to different outputs (such as console or file), adding optional message stamps (like timestamps), and supporting customization through callable functions (such as lambdas for specialized message formatting).]]></summary></entry></feed>