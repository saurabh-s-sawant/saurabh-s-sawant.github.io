<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://saurabh-s-sawant.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://saurabh-s-sawant.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-04-19T19:45:35+00:00</updated><id>https://saurabh-s-sawant.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Exploring Policy-Based Design : A Customizable Message Logger in C++</title><link href="https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign/" rel="alternate" type="text/html" title="Exploring Policy-Based Design : A Customizable Message Logger in C++"/><published>2024-02-04T20:00:00+00:00</published><updated>2024-02-04T20:00:00+00:00</updated><id>https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign</id><content type="html" xml:base="https://saurabh-s-sawant.github.io/blog/2024/policyBasedDesign/"><![CDATA[<p>Policy-based design is a versatile design pattern that underpins many useful features in modern C++, such as smart pointers. Despite its resourcefulness, I never delved into it during my work developing scientific codes.Intrigued by its potential, I decided to explore its application by creating a simple message logger that could be customized to suit user needs. <a href="https://github.com/saurabh-s-sawant/cpp_exercises/blob/main/design/policy_based_design/ex1_msglogger.cpp">Here</a> is the github link to the code.</p> <p>Before diving into the specifics, let’s review the context in which this design pattern shines.</p> <h3 id="overview">Overview</h3> <p>Policy-based design serves as a compile-time counterpart to the well-known strategy pattern. It may be useful in scenarios where when we know the desired behavior (‘what’), but do not know a single, definitive implementation (‘how’). In essence, it allows for multiple ‘how’ implementations, offering flexibility for possible future enhancements or changes in requirements.</p> <p>This decoupling of desired behavior and implementation details enables developers to define various policies at compile-time, dictating different behaviors of a class. This approach provides a high degree of customization and adaptability, exemplified by features such as ‘std::unique_ptr’ allowing users to define custom deleters.</p> <h3 id="example-description">Example Description</h3> <p>Imagine we are developing a complex code, and we require an extensive logger to track the execution flow and to diagnose issues. We would like a message logger that can:</p> <ul> <li>direct messages to different destinations such as console or a user-defined file</li> <li>prepend the log message with some message stamp, such as a timestamp or a process id</li> <li>allow users to pass custom callables for logging special data types or performing additional tasks</li> </ul> <h3 id="implementation-policies">Implementation Policies</h3> <p>To achive these objectives, we will create ‘MsgLogger’ class with the following policies:</p> <ol> <li>StreamPolicy: dictates where the log messages will be directed. Implementations: <ul> <li>WriteToConsole: sends messages to the console.</li> <li>WriteToFile: writes messages to a file (with support for thread safety).</li> </ul> </li> <li>StampPolicy: controls the formatting of prepended message stamps. <ul> <li>NoStamp: opts for no stamp inclusion.</li> <li>WithStamp_TimeSecPrecis: prepends a timestamp to each log message.</li> <li>WithStamp_TimeMicroSecPrecis: prepends a timestamp with microsecond precision.</li> </ul> </li> <li>CallablePolicy: determines whether a callable can be passed to the logger object. <ul> <li>NoCallable: opts not to support a callable.</li> <li>WithCallable: allows users to pass a user-defined callable such as a lambda function.</li> </ul> </li> </ol> <h3 id="implementation-details">Implementation Details</h3> <p>The ‘MsgLogger’ logger class combines these policies to offer a flexible solution. Users can combine these policies according to their need or add new implementations of these policies independently, making code reusable and maintainable.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">StreamPolicy</span><span class="o">=</span><span class="n">WriteToConsole</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">StampPolicy</span><span class="o">=</span><span class="n">NoStamp</span><span class="p">,</span>
          <span class="k">typename</span> <span class="nc">CallablePolicy</span><span class="o">=</span><span class="n">NoCallable</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MsgLogger</span> <span class="o">:</span> <span class="k">private</span> <span class="n">StreamPolicy</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/* Preference for r-value references.
     * l-value strings must be moved while passing as arguments.
     */</span>
    <span class="k">explicit</span> <span class="n">MsgLogger</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">init_msg</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span> 
                       <span class="n">StreamPolicy</span><span class="o">&amp;&amp;</span> <span class="n">stream_policy</span> <span class="o">=</span> <span class="n">StreamPolicy</span><span class="p">())</span> <span class="o">:</span>
    <span class="n">StreamPolicy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">stream_policy</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">StampPolicy</span><span class="o">::</span><span class="n">get_stamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">init_msg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*default F is an empty function */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()&gt;,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="o">=</span><span class="p">{},</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">callable_duration</span><span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{};</span>

        <span class="c1">//forward callable signature and arguments</span>
        <span class="n">CallablePolicy</span><span class="o">::</span><span class="n">call</span><span class="p">(</span><span class="n">callable_duration</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> 
                                                <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="n">StampPolicy</span><span class="o">::</span><span class="n">get_stamp</span><span class="p">()</span> <span class="o">+</span> <span class="n">msg</span> <span class="o">+</span> <span class="n">callable_duration</span><span class="p">);</span>
    <span class="p">}</span>

   <span class="o">~</span><span class="n">MsgLogger</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">//non-copyable</span>
    <span class="n">MsgLogger</span><span class="p">(</span><span class="k">const</span> <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="c1">//movable, let's say</span>
    <span class="n">MsgLogger</span><span class="p">(</span><span class="n">MsgLogger</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">StreamPolicy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">))</span> <span class="p">{}</span>

    <span class="n">MsgLogger</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MsgLogger</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">StreamPolicy</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">that</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>In our design, StreamPolicy is inherited by MsgLogger instead of composed. This choice of inheritance, marked as private, emphasizes that MsgLogger is not a StreamPolicy but is only implemented-in-terms-of it.</p> <p>For instance, the simplest StreamPolicy, WriteToConsole, is defined as follows:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WriteToConsole</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>Inheriting StreamPolicy offers an advantange when the base class, such as WriteToConsole, has no data members. In such cases, compilers optimize the size of the derived class object (MsgLogger object) through ‘empty base class optimization’.</p> <p>A simple ‘WithStamp_TimeMicroSecPrecis’ policy is given below:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WithStamp_TimeMicroSecPrecis</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_stamp</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="kt">uint64_t</span> <span class="n">micros_since_epoch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()).</span><span class="n">count</span><span class="p">();</span>

        <span class="k">auto</span> <span class="n">microseconds</span> <span class="o">=</span> <span class="n">micros_since_epoch</span> <span class="o">%</span> <span class="mi">1000000</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">time_now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
        <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_now</span><span class="p">),</span> <span class="s">"%T"</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">microseconds</span><span class="p">;</span>
        <span class="k">return</span> <span class="s">"["</span> <span class="o">+</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">+</span> <span class="s">"] "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This policy is stateless, as it doesn’t require any data members. Additionally, the ‘get_timestamp’ function operates independently of the message logger object, allowing us to use it statically without the need to store it within the MsgLogger class.</p> <p>The ‘WithCallable’ policy is outlined below:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">WithCallable</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()&gt;,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">call</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">duration</span><span class="p">,</span> <span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">func</span><span class="o">=</span><span class="p">{},</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//convert func to std::function object and test</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="cm">/* func can be invoked.
             * measure duration, output as string.
             */</span>
            <span class="k">auto</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

            <span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>

            <span class="k">auto</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">time_elapsed</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span>
                                <span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">);</span>

            <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
            <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="n">time_elapsed</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="s">" Time taken: "</span> <span class="o">+</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">+</span> <span class="s">" micro-sec.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* func is empty
             * attempting to invoke func will result in std::bad_function_call
             */</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This implementation allows for invoking the forwarded callable and measuring its time. Additionally, it checks if ‘func’ is empty to handle cases where no callable is provided.</p> <h3 id="demonstration">Demonstration</h3> <p>Let’s demonstrate how to use the ‘MsgLogger’ class with different combinations of policies.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//default logger</span>
    <span class="n">MsgLogger</span> <span class="n">logger</span><span class="p">(</span><span class="s">"Hello, this is default  logger!"</span><span class="p">);</span>
    <span class="n">logger</span><span class="p">(</span><span class="s">"default logger is logging..."</span><span class="p">);</span>

    <span class="c1">//file logger without callable</span>
    <span class="n">MsgLogger</span><span class="o">&lt;</span><span class="n">WriteToFile</span><span class="p">,</span> <span class="n">WithStamp_TimeMicroSecPrecis</span><span class="o">&gt;</span>
        <span class="n">file_logger</span><span class="p">{</span><span class="s">"Hello, this is file_logger!"</span><span class="p">,</span> <span class="n">WriteToFile</span><span class="p">(</span><span class="s">"file.dat"</span><span class="p">)};</span>
    <span class="n">file_logger</span><span class="p">(</span><span class="s">"file_logger is logging..."</span><span class="p">);</span>

    <span class="c1">//file logger with callable</span>
    <span class="n">MsgLogger</span><span class="o">&lt;</span><span class="n">WriteToFile</span><span class="p">,</span> <span class="n">WithStamp_TimeMicroSecPrecis</span><span class="p">,</span> <span class="n">WithCallable</span><span class="o">&gt;</span> <span class="n">callable_logger</span>
    <span class="p">{</span><span class="s">"Hello, I am callable_logger!"</span><span class="p">,</span> <span class="n">WriteToFile</span><span class="p">(</span><span class="s">"file.dat"</span><span class="p">)};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">complex_vec</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">log_vector</span><span class="p">(</span><span class="n">callable_logger</span><span class="p">,</span> <span class="n">complex_vec</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>where ‘log_vector’ is:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">LoggerType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">VecType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">log_vector</span><span class="p">(</span><span class="n">LoggerType</span><span class="o">&amp;</span> <span class="n">logger</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VecType</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">logger</span><span class="p">(</span><span class="s">"Vector is printed! "</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>    
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="o">:</span> <span class="n">vec</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">oss</span><span class="p">;</span>
            <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">" vec["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]: "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">real</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">imag</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span><span class="p">;</span>
            <span class="n">logger</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>The output written to console reads:</p> <pre><code class="language-dat">
Hello, this is default  logger!
default logger is logging...
</code></pre> <p>The output written to ‘file.dat’ reads:</p> <pre><code class="language-dat">
[10:28:07.134316] Hello, I am callable_logger!
[10:28:07.134321]  vec[0]: 1 + 2i
[10:28:07.134322]  vec[1]: 3 + 4i
[10:28:07.134324]  vec[2]: 5 + 6i
[10:28:07.134326] Vector is printed!  Time taken: 5 micro-sec.


[10:28:07.134284] Hello, this is file_logger!
[10:28:07.134306] file_logger is logging...
</code></pre> <h3 id="further-exploration">Further Exploration</h3> <p>We have only scratched the surface of the power of this design pattern. Policies can extend beyond simple function objects and include template instantiations or even templates themselves. Additionally, policy classes can be composed rather than inherited, which is useful if policies hold a state and need to be stored in the policy class.</p> <p>Combining policy-based design with the Curiously Recurring Template Pattern (CRTP) allows for modifications to the public interface of a class. Moreover, this pattern can be leveraged to create policies for writing unit tests, enabling robust testing strategies.</p> <p>An interesting application of policy-based design involves combining it with the type-erasure technique to unify different customized instances of the policy class into a single type, as seen in std::shared_ptr.</p> <p>However, it’s important to note a major criticism of this design pattern. When dealing with many policies, specifying a non-default policy towards the end of a long policy list requires declaring all policies before it. While this challenge can be mitigated by organizing policies thoughtfully and using policy adapters with aliases, it is worth considering in other possible design patterns that may be used instead.</p> <p>For further exploration and reading, please refer to:</p> <ul> <li><strong>Hands-On Design Patterns with C++</strong> by Fedor Pikus</li> <li><strong>Modern C++ Design: Generic Programming and Design Patterns Applied</strong> by Andrei Alexandrescu</li> <li><a href="https://www.youtube.com/watch?v=fauJG1WEDUM">Policy-based design in C++20</a> by Goran Arandjelović on Youtube</li> <li><a href="https://www.foonathan.net/2017/02/policy-based-design-problem/">The problem with policy-based design</a> by Jonathan Müller</li> <li><a href="https://stackoverflow.com/questions/20276659/policy-based-approach-with-logger">Policy based approach with logger</a> on stackoverflow</li> <li><strong>ChatGPT</strong> (with a grain of salt)</li> </ul>]]></content><author><name></name></author><category term="code"/><category term="generic_programming"/><summary type="html"><![CDATA[Message logger offers three policies&#58; directing log messages to different outputs (such as console or file), adding optional message stamps (like timestamps), and supporting customization through callable functions (such as lambdas for specialized message formatting).]]></summary></entry></feed>